<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tas: Toy Two Pass Assembler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tas
   </div>
   <div id="projectbrief">Toy two pass assembler in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Toy Two Pass Assembler </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The project is based on Yonatan Zilpa's excersie. A brief explanation can be found <a href="https://www.magmath.com/english/programming/c_programming_language/projects/two_pass_assembler.php">here</a>. The majority of the following is just a direct copy of that site. Some differences:</p><ul>
<li>I'm using hexadecimal (base 16) numeric system insted of octal.</li>
<li>.entry MAIN needed to be defined explicitly.</li>
<li>There wont be any generated .ent/.ext files, if they are not needed.</li>
</ul>
<p>Documentation can be found <a href="https://g0mb4.github.io/tas/">here</a>.</p>
<h1>"Hardware"</h1>
<p>Our computer architecture consists from CPU (Central Processing Unit), registers and Random Access Memory RAM, where part of the memory is being used as a stack. The size of each word in memory is 16 bits. Arithmetics is to be carried by the '2's complement' method. Our computer machine can only handle integers (Positives or negatives), it doesn't handle real numbers.</p>
<h2>Registers</h2>
<p>Our computer machine includes the following list of registers:</p><ul>
<li>Eight general registers (<b>r0</b>, <b>r1</b>, <b>r2</b>, <b>r3</b>, <b>r4</b>, <b>r5</b>, <b>r6</b>, <b>r7</b>)</li>
<li>One Program Counter register (<b>PC</b>).</li>
<li>One Stack Pointer register (<b>SP</b>).</li>
<li>One Status register (<b>PSW</b> - Program Status Word) which has two flags: <b>carry flag</b> and <b>zero flag</b>.</li>
</ul>
<p>All registers are 16 bits in size. The two first bits of the PSW register are C and Z in correspondence The size of memory is 2000 words (each word is 16 bits in size). Characters are coded in ASCII.</p>
<h1>Instructions</h1>
<p>In our computer machine, instruction is a word (16 bits in size) that carries information about the operator and operands. Although instruction is a string of 16 bits, it can be divided into fields. The following table provides further information about the instruction. The bits are in decimal number system.</p>
<table class="doxtable">
<tr>
<th>Fields </th><th>Operation </th><th>Source Operand </th><th></th><th>Destination Operand </th><th></th></tr>
<tr>
<td></td><td></td><td>Addressing Mode </td><td>Register </td><td>Addressing Mode </td><td>Register </td></tr>
<tr>
<td>Bits </td><td>15-12 </td><td>11-9 </td><td>8-6 </td><td>5-3 </td><td>2-0 </td></tr>
</table>
<p>The following table maps operator's name to its corresponding instruction code (opcode).</p>
<table class="doxtable">
<tr>
<th>Operator </th><th>Opcode  </th></tr>
<tr>
<td><code>mov</code> </td><td>0 </td></tr>
<tr>
<td><code>cmp</code> </td><td>1 </td></tr>
<tr>
<td><code>add</code> </td><td>2 </td></tr>
<tr>
<td><code>sub</code> </td><td>3 </td></tr>
<tr>
<td><code>mul</code> </td><td>4 </td></tr>
<tr>
<td><code>div</code> </td><td>5 </td></tr>
<tr>
<td><code>lea</code> </td><td>6 </td></tr>
<tr>
<td><code>inc</code> </td><td>7 </td></tr>
<tr>
<td><code>dec</code> </td><td>8 </td></tr>
<tr>
<td><code>jnz</code> </td><td>9 </td></tr>
<tr>
<td><code>jnc</code> </td><td>a </td></tr>
<tr>
<td><code>shl</code> </td><td>b </td></tr>
<tr>
<td><code>prn</code> </td><td>c </td></tr>
<tr>
<td><code>jsr</code> </td><td>d </td></tr>
<tr>
<td><code>rts</code> </td><td>e </td></tr>
<tr>
<td><code>hlt</code> </td><td>f </td></tr>
</table>
<p>All operators are written in lower case letters, details on the meaning of these operators will be specified later.</p>
<ul>
<li><b>Bits 9-11</b>: This field refers to the addressing mode of the source operand. Depending on the value of this field (numeric values of bits 9-11) , the instruction may refer to additional word (first additional word)</li>
<li><p class="startli"><b>Bits 6-8</b>: This field refers to the register of the source operand. The field (bits 6-8) maps its numeric value n to register rn.</p>
<p class="startli"><em>Notice</em>: If the addressing mode in the source operand does not require the source register, then the source register field are not in use. In such a case the numeric value of the field (bits 6-8) is equal to zero.</p>
</li>
<li><b>Bits 3-5</b>: This field refers to the addressing mode of the destination operand. Depending on the numeric value of this field (bits 3-5) , the instruction may refer to additional word (second additional word)</li>
<li><p class="startli"><b>Bits 0-2</b>: This field refers to the register of the destination operand. The field (bits 0-2) maps its numeric value n to register rn.</p>
<p class="startli"><em>Notice</em>: If the addressing mode in the destination operand does not require the destination register, then the source register field are not in use. In such a case the numeric value of the field (bits 6-8) is equal to zero.</p>
</li>
</ul>
<p>There are six types of addressing modes in our assembly language, some of these modes require additional information, i.e. additional word. The following table provides information on all types of addressing mode.</p>
<table class="doxtable">
<tr>
<th>First Word </th><th></th><th></th><th>Additional Word </th><th>Operand </th><th>Way of Writing </th><th>&#160;&#160;Example&#160;&#160;  </th></tr>
<tr>
<td>Field Value </td><td>Name </td><td>Register </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>0 </td><td>Instant addressing </td><td>zero (not in use) </td><td>yes </td><td>The numeric value of the operand is determined by the numeric value of the additional word. </td><td>The operand is a number preceded by the '#' sign. </td><td><code>mov #-1,r2</code> </td></tr>
<tr>
<td>1 </td><td>Direct addressing </td><td>zero (not in use) </td><td>yes </td><td>The additional word contains memory address. The numeric value of the operand is the value of this address. </td><td>The operand is a label, either declared or expected to be declared later in the file. </td><td><code>mov x,r2</code> </td></tr>
<tr>
<td>2 </td><td>Indirect addressing </td><td>zero (not in use) </td><td>yes </td><td>The numeric value of the additional word contains memory address. The value of this address is also a memory address. The value of the second address is the numeric value of the operand. </td><td>Indirect addressing is indicated by the '@' sign which appeared just before the label. The label is declared in the same way as in the direct addressing mode. </td><td><code>mov @x,r2</code> </td></tr>
<tr>
<td>3 </td><td>Relative addressing </td><td>zero (not in use) </td><td>yes </td><td>The additional word contains an integer number (positive or negative) indicating the distance in words from the current command to the address of the operand. </td><td>The operand is a label, defined as in the case of direct addressing mode, preceded by the '*' sign. </td><td><code>mov *x,r2</code> </td></tr>
<tr>
<td>4 </td><td>Direct register addressing </td><td>n (positive integer) </td><td>no </td><td>Register rn contains the value of the operand. </td><td>The operand is a legal register name. </td><td><code>mov r1,r2</code> </td></tr>
<tr>
<td>5 </td><td>Indirect register addressing </td><td>n (positive integer)) </td><td>no </td><td>Register rn contains information on memory address. This memory address contains the operand. </td><td>The operand is a legal register name indicated by the '@' sign. </td><td><code>mov @r1,r2</code> </td></tr>
</table>
<h2>Machine Instruction Characterization</h2>
<p>Machine instruction may be classified into three different classes (according to the number of operands appeared in each instruction).</p>
<h2>First Class of Operators</h2>
<p>The first class contains all machine instructions that get two operands. Any machine instruction that belongs to this class may contain one of the following operators: </p><div class="fragment"><div class="line">mov, cmp, add, sub, mul, div, lea, shl</div></div><!-- fragment --><p> The following table provides further explanation on the operational aspects of these operators:</p>
<table class="doxtable">
<tr>
<th>Numeric Code </th><th>Operator </th><th>Description </th><th>&#160;&#160;Example&#160;&#160;</th><th>Example Description  </th></tr>
<tr>
<td>0 </td><td><code>mov</code> </td><td>Copies the value of the source operand (the first operand) to the destination operand (the second operand). </td><td><code>mov A, r1</code> </td><td>Copy the value of A to register r1. </td></tr>
<tr>
<td>1 </td><td><code>cmp</code> </td><td>Compare between two operands. The cmp operator subtracts the destination operand from the source operand, without saving the subtraction result, it then updates the zero flag, flag z, in the status register, PSW. </td><td><code>cpm A, r1</code> </td><td>If the values of A and r1 are equal, then the zero flag A, in the status register PSW, is turned on. Else the zero flag is turned off. </td></tr>
<tr>
<td>2 </td><td><code>add</code> </td><td>The destination operand is assigned with the value of the source operand plus the value of the destination operand. </td><td><code>add A, r0</code> </td><td>Register r0 gets the sum of r0 and A. </td></tr>
<tr>
<td>3 </td><td><code>sub</code> </td><td>The destination operand is assigned with the value of the source operand minus the value of the destination operand. </td><td><code>sub #3, r1</code> </td><td>Register r1 is assigned with the value of r1 minus 3. </td></tr>
<tr>
<td>4 </td><td><code>mul</code> </td><td>Destination operand assigned with the value of the source operand times the value of destination operand </td><td><code>mul A, r2</code> </td><td>Register r2 assigned with A times r2. </td></tr>
<tr>
<td>5 </td><td><code>div</code> </td><td>Destination operand is assigned with the value of destination operand divided by the source operand (destination divided by source) </td><td><code>div A, r2</code> </td><td>Register r2 assigned with r2/A. </td></tr>
<tr>
<td>6 </td><td><code>lea</code> </td><td>Acronym for 'load effective address'. This operation loads memory address, marked with the label appeared in the first operand to the destination operand. </td><td><code>lea ABC, r1</code> </td><td>The memory address of label ABC is assigned to register r1. </td></tr>
<tr>
<td>b </td><td><code>shl</code> </td><td>Shift bits to the left in the source operand. The number of shifts is determined by the value of the destination operand. </td><td><code>shl r1, #1</code> </td><td>Register r1 is shifted 1 bit to the left. </td></tr>
</table>
<h2>Second Class of Operators</h2>
<p>The second class contains all machine instructions that gets one operand. In such cases there is no source operand, thus bits 6-11 are meaningless (their values is zero). Any machine instruction in this class may contain one of the following instruction: </p><div class="fragment"><div class="line">inc, dec, jnz, jnc, prn, jsr</div></div><!-- fragment --><p> The following table provides further explanation on the operational aspects of these operators:</p>
<table class="doxtable">
<tr>
<th>Numeric Code </th><th>Operator </th><th>Description </th><th>&#160;&#160;Example&#160;&#160; </th><th>Example Description  </th></tr>
<tr>
<td>7 </td><td><code>inc</code> </td><td>The operand is increased by one. </td><td><code>inc r2</code> </td><td>Register r2 is assigned with r2 plus 1. </td></tr>
<tr>
<td>8 </td><td><code>dec</code> </td><td>The operand is decreased by one. </td><td><code>dec r2</code> </td><td>Register r2 is assigned with r2 minus 1. </td></tr>
<tr>
<td>9 </td><td><code>jnz</code> </td><td>Acronym: jump if not zero. The Program Counter register PC is assigned with the source operand if the Z flag, in the Program Status Word register PSW is not zero. </td><td><code>jnz LINE</code> </td><td>If the Z flag (in the PSW register) is not zero, then PC register is assigned with LINE. </td></tr>
<tr>
<td>a </td><td><code>jnc</code> </td><td>Acronym: jump if not carry. The Program Counter register PC is assigned with zero if the C flag, in the Program Status Word register PSW is not 0. </td><td><code>jnc LINE</code> </td><td>If the C flag (in the PSW register) is not zero, then PC register is assigned with LINE. </td></tr>
<tr>
<td>c </td><td><code>prn</code> </td><td>Prints the ASCII equivalent of the operand to the standard output file (stdout). </td><td><code>prn r1</code> </td><td>The ASCII equivalent character of the value stored in r1 is printed to standard file. </td></tr>
<tr>
<td>d </td><td><code>jsr</code> </td><td>Calls a subroutine that pushes register PC to the running time stack and assign the operand to the Program Counter register PC. </td><td><code>jsr FUNC</code> </td><td>stack[SP] = PC<br />
 SP = SP-1 <br />
 PC = FUNC </td></tr>
</table>
<h2>Third Class of Operators</h2>
<p>The third class contains all machine instructions that gets no operands. In such cases bits 0-11 are meaningless (their values is zero). Any machine instruction in this class may contain one of the following instruction: </p><div class="fragment"><div class="line">rts, hlt</div></div><!-- fragment --><p> The following table provides further explanation on the operational aspects of these operators:</p>
<table class="doxtable">
<tr>
<th>Numeric Code </th><th>Operator </th><th>Description </th><th>&#160;&#160;Example&#160;&#160; </th><th>Example Description  </th></tr>
<tr>
<td>e </td><td><code>rts</code> </td><td>Pops a value from the running time stack and move this value to the Program Counter register. </td><td><code>rts</code> </td><td>SP = SP+1 <br />
 PC = stack[SP] </td></tr>
<tr>
<td>f </td><td><code>hlt</code> </td><td>Halts the program. </td><td><code>hlt</code> </td><td>Halting the program. </td></tr>
</table>
<h2>Legal addressing modes</h2>
<p>The following table contains information on legal addressing mode for the source and destination operands.</p>
<table class="doxtable">
<tr>
<th>Operator </th><th>Legal Addressing Modes for the Source Operand </th><th>Legal Addressing Modes for the Destination Operand  </th></tr>
<tr>
<td><code>mov</code> </td><td>0,1,2,3,4,5 </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>cmp</code> </td><td>0,1,2,3,4,5 </td><td>0,1,2,3,4,5 </td></tr>
<tr>
<td><code>add</code> </td><td>0,1,2,3,4,5 </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>sub</code> </td><td>0,1,2,3,4,5 </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>mul</code> </td><td>0,1,2,3,4,5 </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>div</code> </td><td>0,1,2,3,4,5 </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>lea</code> </td><td>1 </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>inc</code> </td><td>No source operand </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>dec</code> </td><td>No source operand </td><td>1,2,3,4,5 </td></tr>
<tr>
<td><code>jnz</code> </td><td>No source operand </td><td>1,2,3,5 </td></tr>
<tr>
<td><code>jnc</code> </td><td>No source operand </td><td>1,2,3,5 </td></tr>
<tr>
<td><code>shl</code> </td><td>1,2,3,4,5 </td><td>0,1,2,3,4,5 </td></tr>
<tr>
<td><code>prn</code> </td><td>No source operand </td><td>0,1,2,3,4,5 </td></tr>
<tr>
<td><code>jsr</code> </td><td>No source operand </td><td>1,2,3,5 </td></tr>
<tr>
<td><code>rts</code> </td><td>No source operand </td><td>No source operand </td></tr>
<tr>
<td><code>hlt</code> </td><td>No source operand </td><td>No source operand </td></tr>
</table>
<h1>Statements</h1>
<p>Our assembly language is consisted of statements separated by the new line character '\n'. When we look into a file it appeared to be made out of lines of statements, each statement appeared in its own line. Our assembly language has four types of statements. These statements described in the following table.</p>
<table class="doxtable">
<tr>
<th>Type of statement </th><th>General Explanation  </th></tr>
<tr>
<td>Empty Statement </td><td>Line with this kind of statement may contains only white spaces: tab character '\t' or space character ' ' </td></tr>
<tr>
<td>Comment Statement </td><td>The first character in a line with this statement is the semicolon ';' character. This line should be completely ignored by the assembler. </td></tr>
<tr>
<td>Declarative Statement </td><td>This statement is a directive to the assembler program. It does not generate machine instruction. </td></tr>
<tr>
<td>Operation Statement </td><td>This statement generates machine instruction that needs to be executed by the CPU. The statement represent machine instruction in symbolic form. </td></tr>
</table>
<h2>Directive Statement</h2>
<p>Directive statement is of the following form: Directive statement may optionally start with a label, the label has to follow certain syntax rules (to be described later). Directive can start with or without a label, in any case a directive name, preceded by a dot '.' character, must be included. NO whitespace allowed between the '.' character and the directive name. If the directive does include a label, then at least one whitespace character is separating between the label and the '.' character. Following the directive name, whitespace-separated, appearing, in the same line, the directive parameters (the number of parameters is determined by the type of the directive). As mentioned, directive statement may include four types of directive:</p>
<ol type="1">
<li><p class="startli">.data</p>
<p class="startli">The parameter(s) of data is a list of legal numbers separated by a comma ',' character. For example: </p><div class="fragment"><div class="line">.data    +7,-57 ,17   ,    9</div></div><!-- fragment --><p> Notice that any number of whitespace characters may appear between the number(s) and the comma character(s). However, the comma character must separate between two numeric values. The '.data' directive statement directs the assembler to allocate space in its data image where the appropriate numeric parameters is to be stored. It also direct the assembler to advance the data counter by the number of parameters (of the '.data' directive). If the '.data' directive has a label name, then this label name is assigned with the value in the data image (before it was advanced) and get inserted to the symbols table. This way we can refer to certain place in the data image using the label name. For instance, if we write </p><div class="fragment"><div class="line">XYZ:    .data   +7,-57,17,9</div><div class="line">    mov     XYZ, r1</div></div><!-- fragment --><p> then register r1 is assigned with the value +7. If we continue to write </p><div class="fragment"><div class="line">lea    XYZ, r1</div></div><!-- fragment --><p> then r1 would have been assigned with the address (in the data image) that stores the +7 value.</p>
</li>
<li><p class="startli">.string</p>
<p class="startli">The '.string' directive statement gets only one legal string as parameter. The meaning of '.string' directive statement is similar to the '.data' directive statement. The ASCII characters composed the string are coded to their appropriate numeric ASCII values) and get inserted to the data image by their order. At the end a zero value is being inserted, to mark the end of the string. The value of the data counter is to be increase, according to the length of the string + one. If the line includes a label name, then the value of the label name is going to point to the location in memory that stores the ASCII code of the first character of the string, at the same way as it was done for the '.data' string. For instance the directive statement </p><div class="fragment"><div class="line">ABC:    .string    &quot;abcdef&quot;</div></div><!-- fragment --><p> is going to allocate an array of characters of length 7 starting from the address stored in the ABC label name. This "array" is initialized to the ASCII value of characters 'a', 'b', 'c', 'd', 'e', 'f' in correspondence, the array is to be ended with the zero value concatenate to the end of the array.</p>
</li>
<li><p class="startli">.entry</p>
<p class="startli">The '.entry' directive statement gets one parameter only. This parameter is a label name, declared by other directive statement in the very same file where the The purpose of the '.entry' directive statement is to deal handle cases where a label name defined in an assembly source file A needs to be referred by other assembly source file(s) B, C, D, etc. In this case the '.entry' directive statement, written in the file A, gets the label name as its parameter (the '.entry' directive statement has to have a single parameter). For instance, if an assembly source file A contains the following lines </p><div class="fragment"><div class="line">.entry  HELLO</div><div class="line">HELLO:  add     #1, r1</div></div><!-- fragment --><p> then other assembly source file(s), may refer to HELLO label name. Notice that a label at the beginning of the '.entry' directive is meaningless.</p>
</li>
<li><p class="startli">.extern</p>
<p class="startli">The '.extern' directive statement gets one parameter this parameter is the name of a label name defined in other assembly source file. The purpose of this directive statement is to declare that the label has been defined in other source file and that this assembly source file (the one that contains the '.extern' directive statement) is using it. The correspondence between the value of the label, as appeared in the source file where it was defined, and the operation instruction(s) that are using it as an argument is to be done at linking time. </p><div class="fragment"><div class="line">.extern HELLO</div></div><!-- fragment --><p> Notice that a label at the beginning of the '.extern' directive is meaningless.</p>
</li>
</ol>
<h2>Operation Statement</h2>
<p>Operation statement is composed from the following:</p>
<ol type="1">
<li>Optional label.</li>
<li>Operation name.</li>
<li>Operands (the number of operands may be 0, 1 or 2 depending on the operation).</li>
</ol>
<p>The length of a statement (of any type) cannot exceed 80 characters. The name of the operation is to be written in lower case letter, operation name can be one of the 16 operations mentioned above. After the operation name, separated with whitespace character(s), one or two operands may appear. In the case of two operands, the operands are separated with a comma ',' character. As mentioned before, whitespace character(s) may separate the comma and the operands. Operation statement with two operands has the following form:</p>
<table class="doxtable">
<tr>
<th>Label </th><th>Operation </th><th>Operands </th><th></th></tr>
<tr>
<td></td><td></td><td>Source </td><td>Destination </td></tr>
<tr>
<td><code>HELLO:</code> </td><td><code>add</code> </td><td><code>r7,</code> </td><td><code>B</code> </td></tr>
<tr>
<td><code>JUMP:</code> </td><td><code>jnc</code> </td><td></td><td><code>XYZ</code> </td></tr>
<tr>
<td><code>END:</code> </td><td><code>hlt</code> </td><td></td><td></td></tr>
</table>
<h1>Formal Definitions</h1>
<h2>Label</h2>
<p>Every label must begin with an upper or lower case letter, the rest of the label may contain letters or numbers. The length of the label cannot exceed 30 characters. The label ends with a column ':' character. The column character is not part of the label name it is just a sign representing the end of the character. The label must begin with the first column of the line. Label name cannot have more than one definition. The following labels are written correctly. </p><div class="fragment"><div class="line">hEllo:</div><div class="line">x:</div><div class="line">He78940:</div></div><!-- fragment --><p> Label name cannot be the same as register or operation name. The label derived its value from the syntax. Label written at the beginning of '.data' or '.string' directive gets the value of the appropriate data counter. Label written at the beginning of an operation statement gets the value of the appropriate operation counter.</p>
<h2>Number</h2>
<p>Number is a string of decimal digits (0-9) that may optionally be preceded by either '-' or '+' sign. The number gets its value from its decimal representation represented by the string of digits. For instance the numbers </p><div class="fragment"><div class="line">76, -5, +123</div></div><!-- fragment --><p> can be accepted as numbers. As mentioned, we do not handle rational or real numbers, only integers.</p>
<h2>String</h2>
<p>String is a sequence of visible ASCII characters surrounded by double quotation marks. The quotation marks are not part of the string. The string </p><div class="fragment"><div class="line">&quot;Hello World&quot;</div></div><!-- fragment --><p> is an example for legal string.</p>
<h1>Two Pass Assembler</h1>
<p>When the assembler is starting to translate code it needs to carry two major assignments. Its first assignment is to identify and translate the operation code and its second assignment is to determine addresses for all data and variables appeared in the source file(s). For instance, when the assembler reads the following code: </p><div class="fragment"><div class="line">         .entry MAIN</div><div class="line">MAIN:    mov    LEN, r1</div><div class="line">         lea    STR, r2</div><div class="line">LOOP:    jnz    END</div><div class="line">         prn    @r2</div><div class="line">         sub    #1, r1</div><div class="line">         inc    r2</div><div class="line">         jnc    *LOOP</div><div class="line">END:     hlt</div><div class="line">STR:     .string &quot;abcdef&quot;</div><div class="line">LEN:     .data 6</div></div><!-- fragment --><p>it has to replace the operation names mov, lea, jnz, prn, sub, inc, jnc, hlt with their equivalent binary codes, in addition, the assembler has to replace the symbols STR, LEN, MAIN, LOOP, END with their appropriate addresses that have been allocated for the directive statements. Assuming that the code in example I has being translated by the assembler and has been stored (operations and directives) in a memory block that starts from address 0000, then this translation can be described as follow:</p>
<table class="doxtable">
<tr>
<th>Label </th><th>Address </th><th>Command </th><th>Operand(s) </th><th>Machine Code  </th></tr>
<tr>
<td></td><td></td><td><code>.entry</code> </td><td><code>MAIN</code> </td><td></td></tr>
<tr>
<td><code>MAIN:</code> </td><td>0000 </td><td><code>mov</code> </td><td><code>LEN, r1</code> </td><td>0221 </td></tr>
<tr>
<td></td><td>0001 </td><td></td><td></td><td>0014 </td></tr>
<tr>
<td></td><td>0002 </td><td><code>lea</code> </td><td><code>STR, r2</code> </td><td>6222 </td></tr>
<tr>
<td></td><td>0003 </td><td></td><td></td><td>000d </td></tr>
<tr>
<td><code>LOOP:</code> </td><td>0004 </td><td><code>jnz</code> </td><td><code>END</code> </td><td>9008 </td></tr>
<tr>
<td></td><td>0005 </td><td></td><td></td><td>000c </td></tr>
<tr>
<td></td><td>0006 </td><td><code>prn</code> </td><td><code>@r2</code> </td><td>c02a </td></tr>
<tr>
<td></td><td>0007 </td><td><code>sub</code> </td><td><code>#1, r1</code> </td><td>3021 </td></tr>
<tr>
<td></td><td>0008 </td><td></td><td></td><td>0001 </td></tr>
<tr>
<td></td><td>0009 </td><td><code>inc</code> </td><td><code>r2</code> </td><td>7022 </td></tr>
<tr>
<td></td><td>000a </td><td><code>jnc</code> </td><td><code>*LOOP</code> </td><td>a018 </td></tr>
<tr>
<td></td><td>000b </td><td></td><td></td><td>fffa </td></tr>
<tr>
<td><code>END:</code> </td><td>000c </td><td><code>hlt</code> </td><td></td><td>f000 </td></tr>
<tr>
<td><code>STR:</code> </td><td>000d </td><td><code>.string</code> </td><td><code>"abcdef"</code> </td><td>0061 </td></tr>
<tr>
<td></td><td>000e </td><td></td><td></td><td>0062 </td></tr>
<tr>
<td></td><td>000f </td><td></td><td></td><td>0063 </td></tr>
<tr>
<td></td><td>0010 </td><td></td><td></td><td>0064 </td></tr>
<tr>
<td></td><td>0011 </td><td></td><td></td><td>0065 </td></tr>
<tr>
<td></td><td>0012 </td><td></td><td></td><td>0066 </td></tr>
<tr>
<td></td><td>0013 </td><td></td><td></td><td>0000 </td></tr>
<tr>
<td><code>LEN:</code> </td><td>0014 </td><td><code>.data</code> </td><td><code>6</code> </td><td>0006 </td></tr>
</table>
<p>If the assembler maintains a table of all the operation names and their corresponding binary codes, then all operation names can be easily converted. Whenever the assembler reads an operation name it can simply use the table to find its equivalent binary code. In order to carry the same conversion for the addresses of symbols the assembler has to build similar table. For instance, in example I, prior to reading the source file(s) the assembler has no way to know that the LOOP symbol relates to address 0004. Thus, in regards to all symbols that have been defined by the programmer, the assembler has to accomplish two separate tasks. The first task is to build a table of all symbols and their related numeric values, and the second is to replace all the symbols, appeared in the source file(s) with the numeric values of the address fields. This two assignments can be achieved by performing two separate scans (passes) on the source file(s). In the first pass the assembler builds a table of symbols, this table correspond address to each symbol. In the second pass the assembler translate the source file(s) into binary machine code. Notice that the two passes are done by the assembler, during translation (in the assembly time), before the linking process. After the translation process, the program may be linked and load to memory for execution.</p>
<h2>First pass</h2>
<p>In the first pass, each instruction is being substituted with its appropriate code and the table of symbols is being built. The rest of the code are left untouched. The code should be loaded at address zero. After applying the first pass on example I, we should get the following result</p>
<p>The table of symbols:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Value </th><th>Image  </th></tr>
<tr>
<td>MAIN </td><td>0000 </td><td>instruction </td></tr>
<tr>
<td>LOOP </td><td>0004 </td><td>instruction </td></tr>
<tr>
<td>END </td><td>000c </td><td>instruction </td></tr>
<tr>
<td>STR </td><td>0000 </td><td>data </td></tr>
<tr>
<td>LEN </td><td>0007 </td><td>data </td></tr>
</table>
<p>List of entries:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Value  </th></tr>
<tr>
<td>MAIN </td><td>???? </td></tr>
</table>
<p>Data image:</p>
<table class="doxtable">
<tr>
<th>Address </th><th>Value  </th></tr>
<tr>
<td>0000 </td><td>0061 </td></tr>
<tr>
<td>0001 </td><td>0062 </td></tr>
<tr>
<td>0002 </td><td>0063 </td></tr>
<tr>
<td>0003 </td><td>0064 </td></tr>
<tr>
<td>0004 </td><td>0065 </td></tr>
<tr>
<td>0005 </td><td>0066 </td></tr>
<tr>
<td>0006 </td><td>0000 </td></tr>
<tr>
<td>0007 </td><td>0006 </td></tr>
</table>
<p>Instruction image:</p>
<table class="doxtable">
<tr>
<th>Address </th><th>Value  </th></tr>
<tr>
<td>0000 </td><td>0221 </td></tr>
<tr>
<td>0001 </td><td>???? </td></tr>
<tr>
<td>0002 </td><td>6222 </td></tr>
<tr>
<td>0003 </td><td>???? </td></tr>
<tr>
<td>0004 </td><td>9008 </td></tr>
<tr>
<td>0005 </td><td>???? </td></tr>
<tr>
<td>0006 </td><td>c02a </td></tr>
<tr>
<td>0007 </td><td>3021 </td></tr>
<tr>
<td>0008 </td><td>???? </td></tr>
<tr>
<td>0009 </td><td>7022 </td></tr>
<tr>
<td>000a </td><td>a018 </td></tr>
<tr>
<td>000b </td><td>???? </td></tr>
<tr>
<td>000c </td><td>f000 </td></tr>
</table>
<h2>Second pass</h2>
<p>Applying the second pass on the code of example I yields the following final results:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Value </th><th>Image  </th></tr>
<tr>
<td>MAIN </td><td>0000 </td><td>object code </td></tr>
<tr>
<td>LOOP </td><td>0004 </td><td>object code </td></tr>
<tr>
<td>END </td><td>000c </td><td>object code </td></tr>
<tr>
<td>STR </td><td>000d </td><td>object code </td></tr>
<tr>
<td>LEN </td><td>0014 </td><td>object code </td></tr>
</table>
<p>List of entries:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Value  </th></tr>
<tr>
<td>MAIN </td><td>0000 </td></tr>
</table>
<p>Object code:</p>
<table class="doxtable">
<tr>
<th>Address </th><th>Machine Word  </th></tr>
<tr>
<td>0000 </td><td>0221 </td></tr>
<tr>
<td>0001 </td><td>0014 </td></tr>
<tr>
<td>0002 </td><td>6222 </td></tr>
<tr>
<td>0003 </td><td>000d </td></tr>
<tr>
<td>0004 </td><td>9008 </td></tr>
<tr>
<td>0005 </td><td>000c </td></tr>
<tr>
<td>0006 </td><td>c02a </td></tr>
<tr>
<td>0007 </td><td>3021 </td></tr>
<tr>
<td>0008 </td><td>0001 </td></tr>
<tr>
<td>0009 </td><td>7022 </td></tr>
<tr>
<td>000a </td><td>a018 </td></tr>
<tr>
<td>000b </td><td>fffa </td></tr>
<tr>
<td>000c </td><td>f000 </td></tr>
<tr>
<td>000d </td><td>0061 </td></tr>
<tr>
<td>000e </td><td>0062 </td></tr>
<tr>
<td>000f </td><td>0063 </td></tr>
<tr>
<td>0010 </td><td>0064 </td></tr>
<tr>
<td>0011 </td><td>0065 </td></tr>
<tr>
<td>0012 </td><td>0066 </td></tr>
<tr>
<td>0013 </td><td>0000 </td></tr>
<tr>
<td>0014 </td><td>0006 </td></tr>
</table>
<p>When the assembler program is done an object code is generated this object code is to be sent to a linker program. The purpose of the linker program is described as follows:</p>
<ol type="1">
<li>To allocate the program with place in memory (allocation).</li>
<li>To link the object file into one executable file (linking)</li>
<li>To change addresses according to the loading place (relocation)</li>
<li>To physically load the code into memory.</li>
</ol>
<p>After the linker program is done the program can be loaded to memory and is ready to run. We are not going to make further discussion on how the linker program works.</p>
<h1>The format of output files</h1>
<p>The object file written by the assembler provides informations about machine's memory. The first instruction is to be inserted to memory address 0, the second instruction is to be inserted to be inserted to memory address 2,3 or 4 (depending on the length of the first instruction) and so fourth until the translation of the last instruction. The next memory address, after the last translated instruction, contains the data that were built by the '.data' and '.string' instructions, their order of appearance in memory depends on their precedence of appearance in the source file (first instruction occupies first free memory in a rising order).</p>
<h2>The object code file (.oc)</h2>
<p>The object file is composed out of lines of text. The first line contains (in octal) the length of the code and the length of data, both are in terms of memory words. Those two numbers must be separated by white space. Each of the next lines provides information on the content of memory address (in octal form) starting from memory address 0. In addition, for each memory address, occupied by instruction (not data), there appear additional information for the linker. This additional information could be one of the following three characters: 'e' 'a' or 'r'. The character 'a' designates the fact that the content of the memory address is absolute and does not depend on where the file is to be loaded (the assembler assumes it to start from memory address 0). The character 'r' designates the fact that memory address is relocatable and should be added with the appropriate offset, in regards to where the file is to be loaded. The offset is the first memory address from which the first instruction of the program is to be loaded. The letter 'd' designates the fact that the content of the file depends on external variable, the linker program is to take care on the insertion of the appropriate value.</p>
<h2>The entries file (.ent)</h2>
<p>The entries file is composed out of lines of text. Each line contains the entry name and value, as it was computed for this file.</p>
<h2>The externals file (.ext)</h2>
<p>The externals file is composed out of lines of text. Each line contains the name and memory address of the external variable.</p>
<h2>Binary file (.bin)</h2>
<p>The binary file contains the object code in binary (non-text) format. It can't be created, if the source code contains .extern directives.</p>
<h2>Example files</h2>
<h3>test</h3>
<p>Prints the string "abcdef". <em>test.as</em> </p><div class="fragment"><div class="line">; test.as</div><div class="line">; Prints the string &quot;abcdef&quot;.</div><div class="line"></div><div class="line">        .entry MAIN     ; file contains the definition of MAIN</div><div class="line">MAIN:   mov  LEN, r1    ; move LEN(6) to r1</div><div class="line">        lea  STR, r2    ; load the address of STR to r2</div><div class="line">LOOP:   jnz  END        ; if not zero, jump to END</div><div class="line">        prn  @r2        ; print the character at the memory location that r2 holds</div><div class="line">        sub  #1, r1     ; r1 = r1 - 1</div><div class="line">        inc  r2         ; r2 = r2 + 1</div><div class="line">        jnc  *LOOP      ; jump to LOOP of carry flag is not set (sub sets it)</div><div class="line">END:    hlt             ; end of the program</div><div class="line">STR:    .string  &quot;abcdef&quot;   ; string to print</div><div class="line">LEN:    .data   6           ; length of the string</div></div><!-- fragment --><p> <em>test.oc</em> </p><div class="fragment"><div class="line">d 8</div><div class="line">0000 0221 a</div><div class="line">0001 0014 r</div><div class="line">0002 6222 a</div><div class="line">0003 000d r</div><div class="line">0004 9008 a</div><div class="line">0005 000c r</div><div class="line">0006 c02a a</div><div class="line">0007 3021 a</div><div class="line">0008 0001 a</div><div class="line">0009 7022 a</div><div class="line">000a a018 a</div><div class="line">000b fffa a</div><div class="line">000c f000 a</div><div class="line">000d 0061  </div><div class="line">000e 0062  </div><div class="line">000f 0063  </div><div class="line">0010 0064  </div><div class="line">0011 0065  </div><div class="line">0012 0066  </div><div class="line">0013 0000  </div><div class="line">0014 0006</div></div><!-- fragment --><p> <em>test.ent</em> </p><div class="fragment"><div class="line">MAIN 0000</div></div><!-- fragment --> <h3>ps</h3>
<p>The main routine of the program of reversing string "abcdef". <em>ps.as</em> </p><div class="fragment"><div class="line">; ps.as</div><div class="line">; Includes main routine of reversing string &quot;abcdef&quot;</div><div class="line"></div><div class="line">MAIN:   lea STR, STRADD</div><div class="line">        jsr COUNT</div><div class="line">        jsr PRTSTR</div><div class="line">        mov *STRADD, LASTCHAR</div><div class="line">        add LEN, LASTCHAR</div><div class="line">        dec LASTCHAR</div><div class="line">        jsr REVERSE</div><div class="line">        jsr PRTSTR</div><div class="line">        hlt</div><div class="line"></div><div class="line">.entry  STRADD</div><div class="line">.entry  MAIN</div><div class="line">.extern REVERSE</div><div class="line">.extern PRTSTR</div><div class="line">.extern COUNT</div><div class="line"></div><div class="line">STRADD:     .data 0</div><div class="line">STR:        .string &quot;abcdef&quot;</div><div class="line">LASTCHAR:   .data 0</div><div class="line">LEN:        .data 0</div></div><!-- fragment --><p> <em>ps.oc</em> </p><div class="fragment"><div class="line">14 a</div><div class="line">0000 6208 a</div><div class="line">0001 0015 r</div><div class="line">0002 0014 r</div><div class="line">0003 d008 a</div><div class="line">0004 0000 e</div><div class="line">0005 d008 a</div><div class="line">0006 0000 e</div><div class="line">0007 0608 a</div><div class="line">0008 000d a</div><div class="line">0009 001c r</div><div class="line">000a 2208 a</div><div class="line">000b 001d r</div><div class="line">000c 001c r</div><div class="line">000d 8008 a</div><div class="line">000e 001c r</div><div class="line">000f d008 a</div><div class="line">0010 0000 e</div><div class="line">0011 d008 a</div><div class="line">0012 0000 e</div><div class="line">0013 f000 a</div><div class="line">0014 0000  </div><div class="line">0015 0061  </div><div class="line">0016 0062  </div><div class="line">0017 0063  </div><div class="line">0018 0064  </div><div class="line">0019 0065  </div><div class="line">001a 0066  </div><div class="line">001b 0000  </div><div class="line">001c 0000  </div><div class="line">001d 0000  </div></div><!-- fragment --><p> <em>ps.ent</em> </p><div class="fragment"><div class="line">STRADD 0014</div><div class="line">MAIN 0000</div></div><!-- fragment --><p> <em>ps.ext</em> </p><div class="fragment"><div class="line">COUNT 0004</div><div class="line">PRTSTR 0006</div><div class="line">REVERSE 0010</div><div class="line">PRTSTR 0012</div></div><!-- fragment --><h1>Usage of tas</h1>
<div class="fragment"><div class="line">tas &lt;options&gt; source-file</div></div><!-- fragment --><p> where the options are: </p><div class="fragment"><div class="line">-l : prints debugging lists after each pass</div><div class="line">-n : creates NO output files</div><div class="line">-b : creates binary output file</div><div class="line">-h : shows this text</div></div><!-- fragment --><h1>Compilation of tas</h1>
<p>Use <a href="https://premake.github.io">premake5</a> to generate the build configuration.</p>
<p><em>Windows</em> </p><div class="fragment"><div class="line">cd tas</div><div class="line">premake5 vs2017</div><div class="line">cd build</div><div class="line">tas.sln</div></div><!-- fragment --><p> <em>Linux</em> </p><div class="fragment"><div class="line">cd tas</div><div class="line">premake5 gmake</div><div class="line">cd build</div><div class="line">make                # build default (Debug) configuration</div><div class="line">make config=release # build Release configuration</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
